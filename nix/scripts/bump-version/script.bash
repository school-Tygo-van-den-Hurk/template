#!/usr/bin/env bash

set -e

# Separates --option=value into '--option' and 'value'.
# Also splits compact short options like '-abc' into '-a' '-b' '-c'.
new_args=()
while [[ $# -gt 0 ]]; do
  case "$1" in
  -*=*) # Handle --option=value
    key="${1%%=*}"
    val="${1#*=}"
    new_args+=("$key" "$val")
    shift
    ;;
  -[!-]?*) # Handle compact short options (e.g. -abc)
    flags="${1#-}"
    for ((i = 0; i < ${#flags}; i++)); do
      new_args+=("-${flags:i:1}")
    done
    shift
    ;;
  *)
    new_args+=("$1")
    shift
    ;;
  esac
done

set -- "${new_args[@]}"

verbose=0
quiet=0
ignore_changes=0
NEW_VERSION=${NEW_VERSION:-""}

print_usage() {
  echo "Usage: $(basename "$0") [options]                                               "
  echo "                                                                                "
  echo "  -h, --help:            Print this help message.                               "
  echo "                                                                                "
  echo "  -v, --verbose:         Print extra information. Cannot be combined with       "
  echo "                         '--quiet'. Exits with exit code 2 if combined.         "
  echo "                                                                                "
  echo "  -q, --quiet:           Print less information. Cannot be combined with        "
  echo "                         '--verbose'. Exits with exit code 2 if combined.       "
  echo "                                                                                "
  echo "  -i, --ignore-changes:  Do not fail if the working tree is dirty               "
  echo "                                                                                "
  echo "  -t, --to:              The version to bump to. If left blank is determined    "
  echo "                         automatically. Can also be set using the 'NEW_VERSION' "
  echo "                         environment variable.                                  "
  echo "                                                                                "
}

# Loop through arguments
while [[ $# -gt 0 ]]; do
  case $1 in
  -v | --verbose)
    verbose=1
    shift
    ;;
  -q | --quiet)
    quiet=1
    shift
    ;;
  -h | --help)
    print_usage
    exit 0
    ;;
  -t | --to)
    NEW_VERSION="$2"
    shift 2
    ;;
  -i | --ignore-changes)
    ignore_changes=1
    shift
    ;;
  *)
    echo "Unknown option: $1"
    exit 1
    ;;
  esac
done

print() {
  if [[ $quiet -eq 0 ]]; then
    echo "$@"
  fi
}

verbose_print() {
  if [[ $verbose -eq 1 ]]; then
    echo "$@"
  fi
}

if [[ $verbose -eq 1 && $quiet -eq 1 ]]; then
  echo "Cannot combine '--verbose' and '--quiet'."
  exit 2
fi

if [[ $ignore_changes -eq 0 ]]; then
  if [ -n "$(git status --porcelain)" ]; then
    echo "Error: Working Tree is not clean" 1>&2
    exit 1
  fi
fi

if [[ $verbose -eq 1 ]]; then
  print "using convco version: $(convco --version)"
fi

ROOT=$(git rev-parse --show-toplevel)
NIX_EXPRESSION="builtins.toFile \"config.json\" (builtins.toJSON (import $ROOT/.config/convco.nix))"
CONFIG=$(nix eval --expr "$NIX_EXPRESSION" --impure)
CHANGELOG="$ROOT/changelog.md"

verbose_print "CONFIG: $CONFIG"
verbose_print "CHANGELOG: $CHANGELOG"

if [ -z "$NEW_VERSION" ]; then
  NEW_VERSION=$(convco --config "$CONFIG" version --bump)
fi

verbose_print "NEW_VERSION: $NEW_VERSION"

print "Updating changelog..."
convco --config "$CONFIG" changelog --unreleased "$NEW_VERSION" | sed 's/^\* /- /' > "$CHANGELOG"
print "Changelog updated!"

print "Committing changes..."
git add "$CHANGELOG"
git commit --message="docs(changelog): Updated changelog for version $NEW_VERSION" \
  --message="Autogenerated by running \`nix run .#bump-version\`." --no-verify
print "Changes committed!"

print "Creating new tag..."
git tag "$NEW_VERSION" --message="Autogenerated by running \`nix run .#bump-version\`."
print "New tag ($NEW_VERSION) created!"
